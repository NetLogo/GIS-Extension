extensionName = "gis"
markdownTemplate = """
# GIS Extension for NetLogo

This package contains the NetLogo GIS extension.

{{> BUILDING.md}}

{{> USING.md}}

## Primitives

{{#contents}}
### {{fullCategoryName}}

{{#prims}}
[`{{name}}`](#{{primitive.extensionName}}{{primitive.name}})
{{/prims}}

{{/contents}}

{{#primitives}}
{{> primTemplate}}
{{/primitives}}

{{> LICENSE.md}}
"""
additionalVariables = {
  netlogoUrl: "http://ccl.northwestern.edu/netlogo/docs/"
},
primTemplate = """
### `{{name}}`

```NetLogo
{{#examples}}
{{#isOptional}}({{/isOptional}}{{primitive.fullName}}{{#args}} *{{argumentPlaceholder}}*{{/args}}{{#isOptional}}){{/isOptional}}
{{/examples}}
```

{{{description}}}
"""
filesToIncludeInManual = [ "USING.md", "primitives" ]
tableOfContents = {
  "coord"   : "Coordinate System Primitives",
  "data"    : "Dataset Primitives",
  "vector"  : "VectorDataset Primitives",
  "raster"  : "RasterDataset Primitives",
  "drawing" : "Drawing Primitives"
}
primitives = [
  {
    name: set-transformation,
    type: command,
    tags: [ "coord" ],
    arguments: [ { name: gis-envelope, type: list }, { name: netlogo-envelope, type: list } ]
    description: """
Defines a mapping between GIS coordinates and NetLogo coordinates.
The *gis-envelope* and *netlogo-envelope* parameters must
each be four-element lists consisting of:

```
[minimum-x maximum-x minimum-y maximum-y]
```

The scale of the transformation will be equal to the minimum of the
scale necessary to make the mapping between the ranges of x values
and the scale necessary to make the mapping between the ranges of y
values. The GIS space will be centered in NetLogo space.

For example, the following two lists would map all of geographic
(latitude and longitude) space in degrees to NetLogo world space,
regardless of the current dimensions of the NetLogo world:

```
(list -180 180 -90 90)
(list min-pxcor max-pxcor min-pycor max-pycor)
```

However, if you're setting the envelope of the NetLogo world,
you should probably be using [set-world-envelope](#gisset-world-envelope).
"""
  },
  {
    name: set-transformation-ds,
    type: command,
    tags: [ "coord" ],
    arguments: [ { name: gis-envelope, type: list }, { name: netlogo-envelope, type: list } ]
    description: """
Does the same thing as [set-transformation](#gisset-transformation) above, except that
it allows the scale for mapping the range of x values to be
different than the scale for y values. The "-ds" on the
end stands for "different scales". Using different scales
will cause distortion of the shape of GIS features, and so it is
generally not recommended, but it may be useful for some models.

Here is an example of the difference between [set-transformation](#gisset-transformation) and [set-transformation-ds](#gisset-transformation-ds):

<table width="80%" border="1" rules="cols" style="border-collaps: separate; border-spacing: 4px; text-align: center; margin: 0 auto;">
<tr>
  <td style="padding: 8px">
    <img alt="" src="images/set-transformation.png" width="200">
  <td style="padding: 8px">
    <img alt="" src="images/set-transformation-ds.png" width="200">
  <tr>
  <td style="padding: 8px">
    Using [set-transformation](#gisset-transformation),
    the scale along the x and y axis is the same, preserving the
    round shape of the Earth in this Orthographic projection.
  <td style="padding: 8px">
    Using [set-transformation-ds](#gisset-transformation-ds), the
    scale along the x axis is stretched so that the earth covers
    the entire NetLogo View, which in this case distorts the shape
    of the Earth.
</table>
"""
  },
  {
    name: set-world-envelope,
    type: command,
    tags: [ "coord" ],
    arguments: [ { name: gis-envelope, type: list } ],
    description: """
A shorthand for setting the transformation by mapping the envelope
of the NetLogo world to the given envelope in GIS space, while
keeping the scales along the x and y axis the same. It is
equivalent to:

```
set-transformation gis-envelope (list min-pxcor max-pxcor min-pycor max-pycor)
```

This primitive is supplied because most of the time you'll want
to set the envelope of the entire NetLogo world, rather than just a
part of it.
"""
  },
  {
    name: set-world-envelope-ds,
    type: command,
    tags: [ "coord" ],
    arguments: [ { name: gis-envelope, type: list } ],
    description: """
A shorthand for setting the transformation by mapping the envelope
of the NetLogo world to the given envelope in GIS space, using
different scales along the x and y axis if necessary. It is
equivalent to:

```
set-transformation-ds gis-envelope (list min-pxcor max-pxcor min-pycor max-pycor)
```

See the [pictures](#transformation-example) above for
the difference between using equal scales for x and y coordinates
and using different scales.
"""
  },
  {
    name: world-envelope,
    tags: [ "coord" ],
    type: reporter,
    returns: list,
    description: """
Reports the envelope (bounding rectangle) of the NetLogo world,
transformed into GIS space. An envelope consists of a four-element
list of the form:

```
[minimum-x maximum-x minimum-y maximum-y]
```

"""
  },
  {
    name: envelope-of,
    type: reporter,
    returns: list,
    tags: [ "coord" ],
    arguments: [ { name: thing, type: anything } ],
    description: """
Reports the envelope (bounding rectangle) of *thing* in GIS
coordinates. The *thing* may be an Agent, an AgentSet, a
RasterDataset, a VectorDataset, or a VectorFeature. An envelope
consists of a four-element list of the form:

```
[minimum-x maximum-x minimum-y maximum-y]
```

"""
  },
  {
    name: envelope-union-of,
    type: reporter,
    returns: list,
    tags: [ "coord" ],
    arguments: [ { name: envelope1, type: list }, { name: envelope2, type: list } ],
    alternateArguments: [ { name: "envelope1...", type: "repeatable list" } ],
    description: """
Reports an envelope (bounding rectangle) that entirely contains the
given envelopes. An envelope consists of a four-element list of the
form

```
[minimum-x maximum-x minimum-y maximum-y]
```

No assumption is made about the coordinate system of the arguments,
though if they are not in the same coordinate system, results will
be unpredictable.
"""
  },
  {
    name: load-coordinate-system,
    type: command,
    tags: [ "coord" ],
    arguments: [ { name: file, type: string } ]
    description: """
Loads a new global projection used for projecting or re- projecting
GIS data as it is loaded from a file. The file must contain a valid
<a href="http://geoapi.sourceforge.net/2.0/javadoc/org/opengis/referencing/doc-files/WKT.html" target="_blank">
Well-Known Text (WKT)</a> projection description.

WKT projection files are frequently distributed alongside GIS data
files, and usually have a ".prj" filename extension.

Relative paths are resolved relative to the location of the current
model, or the user's home directory if the current model
hasn't been saved yet.

The GIS extension does not support all WKT coordinate systems and
projections. Only geographic (`"GEOGCS"`) and
projected (`"PROJCS"`) coordinate systems are
supported. For projected coordinate systems, only the following
projections are supported:

* Albers_Conic_Equal_Area
* Lambert_Conformal_Conic_2SP
* Polyconic
* Lambert_Azimuthal_Equal_Area
* Mercator_1SP
* Robinson
* Azimuthal_Equidistant
* Miller
* Stereographic
* Cylindrical_Equal_Area
* Oblique_Mercator
* Transverse_Mercator
* Equidistant_Conic
* hotine_oblique_mercator
* Gnomonic
* Orthographic

See <a href="http://remotesensing.org/geotiff/proj_list/" target="_blank">remotesensing.org</a>
for a complete list of WKT projections and their parameters.
"""
  },
  {
    name: set-coordinate-system,
    type: command,
    tags: [ "coord" ],
    arguments: [ { name: system, type: "string or list" } ]
    description: """
Sets the global projection used for projecting or re- projecting
GIS data as it is loaded. The *system* must be either a string
in <a href="http://geoapi.sourceforge.net/2.0/javadoc/org/opengis/referencing/doc-files/WKT.html" target="_blank">
Well-Known Text (WKT) format</a>, or a NetLogo list that consists
of WKT converted to a list by moving each keyword inside its
associated brackets and putting quotes around it. The latter is
preferred because it makes the code much more readable.

The same limitations on WKT support apply as described above in the
documentation for [load-coordinate-system](#gisload-coordinate-system)
"""
  },
  {
    name: project-lat-lon,
    type: reporter,
    tags: [ "coord" ],
    arguments: [ 
      { name: latitude,  type: number },
      { name: longitude, type: number }
     ],
    returns: list,
    description: """
    Report the position, in NetLogo space, of the given latitude
    and longitude pair according to the current map projection and
    transformation. 

    Like the `location-of` primitive, the reported xcor and ycor
    values are reported in a two-item list of `[xcor ycor]` 
    and an empty list if the specified point is outside of 
    the bounds of the netlogo world. 
    For instance:
    ```
    let location-of-abbey-road-studios gis:project-lat-lon 51.5320787 -0.1802646
    let abbey-road-xcor item 0 location-of-abbey-road-studios
    let abbey-road-ycor item 1 location-of-abbey-road-studios
    ```

    Note that this primitive assumes that the given lat/lon pair 
    are relative to the WGS84 datum/ellipsoid. If your
    data is based on GPS observations or GeoJson files, then your 
    data is already relative to WGS84. If you are unsure about 
    what datum your data is, then you should probably just assume
    it is WGS84 and use this primitive. However, if you do know
    that your data is relative to a different datum and that
    extra degree of precision is important to you (if you are,
    say, comparing values from location-of and project-lat-lon)
    then you should use `project-lat-lon-from-ellipsoid` and 
    specify the desired datum's ellipsoid. 
"""
  },
  {
    name: project-lat-lon-from-ellipsoid,
    type: reporter,
    tags: [ "coord" ],
    arguments: [ 
      { name: latitude,  type: number },
      { name: longitude, type: number },
      { name: ellipsoid-radius,  type: number },
      { name: ellipsoid-inverse-flattening, type: number }
     ],
    returns: list,
    description: """
    Report the position, in NetLogo space, of the given latitude
    and longitude pair according to the current map projection and
    transformation and the given ellipsoid parameters. 

    Like the `location-of` primitive, the reported xcor and ycor
    values are reported in a two-item list of `[xcor ycor]`
    and an empty list if the specified point is outside of 
    the bounds of the netlogo world. 

    The two defining parameters of a  ellipsoid for 
    the purposes of this primitive are the radius and the 
    inverse flattening metric. These parameters can be 
    easily found by examining either the WKT definition
    of a given projection/datum pair or the .prj file for 
    the desired datum. For example, if you open the .prj file
    for a shapefile exported with the WGS66 datum in a text editor, 
    you will see, somewhere in the file, this bit of text:
    `DATUM["D_WGS_1966",SPHEROID["NWL_9D",6378145,298.25]]`. 
    If you look at the `SPHEROID` section of that text, the
    first number is the radius of that ellipoid and the 
    second is the inverse flattening. 

    Once we have these numbers, we can project data that is 
    relative to WGS66 like so:
    ```
    let location gis:project-lat-lon my-lat my-lon 6378145 298.25
    ```

    For more on earth ellipoids, see: https://en.wikipedia.org/wiki/Earth_ellipsoid
"""
  },
  {
    name: load-dataset,
    type: reporter,
    reports: "Raster dataset",
    tags: [ "data" ],
    arguments: [ { name: file, type: string } ]
    description: """
Loads the given data file, re-projecting the data as necessary. 

Relative paths are resolved relative to the location of the current
model, or the user's home directory if the current model
hasn't been saved yet.

For ESRI shapefiles and ESRI grid files, if there is a ".prj" file 
associated with the file, then `load-datset` will consult that file
and re-project to the current global projection if needed. If no ".prj"
file is found, then the data is assumed to use the same projection as
the current global coordinate system.

For GeoJSON files, as per the most-recent specification (RFC 7946), 
the coordinate system for GeoJSON files is always WGS84 and will be 
imported accordingly. 

Currently, three types of data file are supported:

* "**.shp**" (ESRI shapefile): contains vector data,
  consisting of points, lines, or polygons. When the target file is a
  shapefile, `load-dataset` reports a VectorDataset.
* "**.asc**" or "**.grd**" (ESRI ASCII grid):
  contains raster data, consisting of a grid of values. When
  the target file is an ASCII grid file, `load-dataset`
  reports a RasterDataset.
* "**.geojson**" or "**.json**" (GeoJSON): contains vector data 
  similar to shapefiles and similarly reports a VectorDataset. 

Note that not all aspects of the GeoJSON standard are supported. 
In particular, to be properly imported, a GeoJSON file must 
satisfy the following: 

* It only contain numeric or string data within the properties. 
  all other json data will be stringified. 
* All "Features" within a "FeatureCollection" must be of the same
  shape type ("Point", "LineString", etc.) Additionally, if not all
  the "Features" in the "FeatureCollection" have the same set of 
  property names, default values will be supplied where there
  are missing entries (0 for numbers and "" for strings.)
* It must not use "GeometryCollection", which is not supported
  
"""
  },
  {
    name: store-dataset,
    type: command,
    tags: [ "data" ],
    arguments: [ { name: dataset, type: Dataset }, { name: file, type: string } ],
    description: """
Exports the given dataset to the given file. 

For VectorDatasets, two file formats are supported, ESRI shapefiles
and GeoJSON. If the given file name ends in ".geojson" or ".json", 
then the file will be exported as a GeoJSON file. If the file name
ends in any other extension or no extension at all, the dataset
will be exported as a shapefile and the associated file extensions
will be supplied (".shp", ".prj", etc.)

For RasterDatasets, only ESRI ASCII grid files are supported and 
the associated file extensions will be automatically supplied.

Relative paths are resolved relative to the location of the current 
model, or the user's home directory if the current model hasn't 
been saved yet.
"""
  },
  {
    name: type-of,
    type: reporter,
    returns: string,
    tags: [ "data" ],
    arguments: [ { name: dataset, type: Dataset } ],
    description: """Reports the type of the given GIS dataset: either "VECTOR" or "RASTER""""
  },
  {
    name: patch-dataset,
    type: reporter,
    reports: "raster",
    tags: [ "data" ],
    arguments: [ { name: patch-variable, type: reference } ],
    description: """
Reports a new raster whose cells correspond directly to NetLogo
patches, and whose cell values consist of the values of the given
patch variable. This primitive is basically the inverse of [apply-raster](#gisapply-raster);
`apply-raster` copies values from a raster dataset to a patch variable, while this
primitive copies values from a patch variable to a raster dataset.
"""
  },
  {
    name: turtle-dataset,
    type: reporter,
    returns: dataset,
    tags: [ "data" ],
    arguments: [ { name: turtle-set, type: turtleset } ]
    description: """
Reports a new, point VectorDataset built from the turtles in the
given agentset. The points are located at locations of the turtles,
translated from NetLogo space into GIS space using the current
coordinate transformation. And the dataset's properties consist
of all of the turtle variables common to every turtle in the
agentset.
"""
  },
  {
    name: link-dataset
    type: reporter,
    returns: dataset,
    tags: [ "data" ],
    arguments: [ { name: link-set, type: linkset } ]
    description: """
Reports a new, line VectorDataset built from the links in the given
agentset. The endpoints of each line are at the location of the
turtles connected by each link, translated from NetLogo space into
GIS space using the current coordinate transformation. And the
dataset's properties consist of all of the link variables
common to every link in the agentset.
"""
  },
  {
    name: shape-type-of,
    type: reporter,
    returns: string,
    tags: ["vector"],
    arguments: [ { name: VectorDataset, type: dataset } ],
    description: """
Reports the shape type of the given dataset. The possible output
values are "POINT", "LINE", and "POLYGON"."""
  },
  {
    name: property-names,
    type: reporter,
    returns: list,
    tags: ["vector"],
    arguments: [ { name: VectorDataset, type: dataset } ]
    description: """
Reports a list of strings where each string is the name of a
property possessed by each VectorFeature in the given
VectorDataset, suitable for use in [gis:property-value](#gisproperty-value).
"""
  },
  {
    name: feature-list-of,
    type: reporter,
    returns: list,
    tags: ["vector"],
    arguments: [ { name: VectorDataset, type: dataset } ]
    description: "Reports a list of all VectorFeatures in the given dataset."
  },
  {
    name: vertex-lists-of,
    type: reporter,
    returns: list,
    tags: ["vector"],
    arguments: [ { name: VectorFeature, type: feature } ]
    description: """
Reports a list of lists of Vertex values. For point datasets, each
vertex list will contain exactly one vertex: the location of a
point. For line datasets, each vertex list will contain at least
two points, and will represent a "polyline", connecting
each adjacent pair of vertices in the list. For polygon datasets,
each vertex list will contain at least three points, representing a
polygon connecting each vertex, and the first and last vertices in
the list will be the same.
"""
  },
    {
    name: centroid-of,
    type: reporter,
    returns: vertex,
    tags: ["vector"],
    arguments: [ { name: VectorFeature, type: feature } ],
    description: """
Reports a single Vertex representing the centroid (center of
gravity) of the given feature. For point datasets, the centroid is
defined as the average location of all points in the feature. For
line datasets, the centroid is defined as the average of the
locations of the midpoints of all line segments in the feature,
weighted by segment length. For polygon datasets, the centroid is
defined as the weighted sum of the centroids of a decomposition of
the area into (possibly overlapping) triangles. See <a href="http://www.faqs.org/faqs/graphics/algorithms-faq/" target="_blank">this FAQ</a>
for more details on the polygon centroid algorithm.
"""
  },
  {
    name: location-of,
    type: reporter,
    returns: list,
    tags: ["vector"],
    arguments: [ { name: Vertex, type: vertex } ]
    description: """
Reports a two-element list containing the x and y values (in that
order) of the given vertex translated into NetLogo world space
using the current transformation, or an empty list if the given
vertex lies outside the NetLogo world.
"""
  },
  {
    name: property-value,
    tags: ["vector"],
    type: reporter,
    returns: anything,
    arguments: [ { name: VectorFeature, type: feature }, { name: property-name, type: string } ]
    description: """
Reports the value of the property with the given name for the given
VectorDataset. The reported value may be a number, a string, or a
boolean value, depending on the type of the field in the underlying
data file.

For shapefiles, values from dBase `CHARACTER` and
`DATE` fields are returned as strings, values from
`NUMBER` and `FLOAT` fields are returned as numbers,
and values from `LOGICAL` fields are returned as boolean
values. `MEMO` fields are not supported. `DATE`
values are converted to strings using ISO 8601 format
(`YYYY-MM-DD`).
"""
  },
  {
    name: find-features,
    type: reporter,
    returns: list,
    tags: ["vector"],
    arguments: [ { name: VectorDataset, type: dataset }, { name: property-name, type: string }, { name: specified-value, type: string } ],
    description: """
Reports a list of all VectorFeatures in the given dataset whose
value for the property *property-name* matches *specified-value* (a string).
Value comparison is not case sensitive, and the wildcard
character "*" will match any number of occurrences
(including zero) of any character.
"""
  },
  {
    name: find-one-feature,
    type: reporter,
    returns: feature,
    tags: ["vector"],
    arguments: [
      { name: VectorDataset, type: dataset },
      { name: property-name, type: string },
      { name: specified-value, type: string }
    ],
    description: """
Reports the first VectorFeature in the dataset whose value for the
property *property-name* matches the given string. Value
comparison is not case sensitive, and the wildcard character
"*" will match any number of occurrences (including zero)
of any character. Features are searched in the order that they
appear in the data file that was the source of the dataset, and
searching stops as soon as a match is found. Reports
`nobody` if no matching VectorFeature is found.
"""
  },
  {
    name: find-less-than,
    type: reporter,
    returns: list,
    tags: ["vector"],
    arguments: [ { name: VectorDataset, type: dataset }, { name: property-name, type: string }, { name: value, type: "string or number" } ]
    description: """
Reports a list of all VectorFeatures in the given dataset whose
value for the property *property-name* is less than the given
*value*. String values are compared using case-sensitive
lexicographic order as defined in the <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/String.html#compareTo(java.lang.String)" target="_blank">
Java Documentation</a>. Using a string value for a numeric property
or a numeric value for a string property will cause an error.
"""
  },
  {
    name: find-greater-than
    tags: ["vector"],
    type: reporter,
    returns: list,
    arguments: [ { name: VectorDataset, type: dataset }, { name: property-name, type: string }, { name: value, type: "string or number" } ]
    description: """
Reports a list of all VectorFeatures in the given dataset whose
value for the property *property-name* is greater than the
given *value*. String values are compared using case-sensitive
lexicographic order as defined in the <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/String.html#compareTo(java.lang.String)" target="_blank">
Java Documentation</a>. Using a string value for a numeric property
or a numeric value for a string property will cause an error.
"""
  },
  {
    name: find-range,
    type: reporter,
    returns: list,
    tags: ["vector"],
arguments: [ { name: VectorDataset, type: dataset }, { name: property-name, type: string }, { name: minimum-value, type: "number or string" }, { name: maximum-value, type: "number or string" } ]
    description: """
Reports a list of all VectorFeatures in the given dataset whose
value for the property *property-name* is strictly greater
than *minimum-value* and strictly less than
*maximum-value*. String values are compared using
case-sensitive lexicographic order as defined in the <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/String.html#compareTo(java.lang.String)" target="_blank">
Java Documentation</a>. Using a string value for a numeric property
or a numeric value for a string property will cause an error.
"""
  },
  {
    name: property-minimum,
    type: reporter,
    returns: "number or string",
    tags: ["vector"],
    arguments: [ { name: VectorDataset, type: dataset }, { name: property-name, type: string } ],
    description: """
Reports the smallest value for the given property over all of the
VectorFeatures in the given dataset. String values are compared
using case-sensitive lexicographic order as defined in the <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/String.html#compareTo(java.lang.String)" target="_blank">
Java Documentation</a>.
"""
  },
    {
    name: property-maximum
    tags: ["vector"],
    type: reporter,
    returns: "number or string",
    arguments: [ { name: VectorDataset, type: dataset }, { name: property-name, type: string } ],
    description: """
Reports the largest value for the given property over all of the
VectorFeatures in the given dataset. String values are compared
using case-sensitive lexicographic order as defined in the <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/String.html#compareTo(java.lang.String)" target="_blank">
Java Documentation</a>.
"""
  },
  {
    name: apply-coverage,
    type: command,
    tags: ["vector"],
    arguments: [
      { name: VectorDataset, type: dataset },
      { name: property-name, type: string },
      { name: patch-variable, type: reference }
    ],
    description: """
Copies values from the given property of the VectorDataset's
features to the given patch variable. The dataset must be a
`polygon` dataset; points and lines are not supported.

For each patch, it finds all VectorFeatures that intersect that
patch. Then, if the property is a string property, it computes the
majority value by computing the total area of the patch covered by
VectorFeatures having each possible value of the property, then
returning the value which represents the largest proportion of the
patch area. If the property is a numeric property, it computes a
weighted average of property values from all VectorFeatures which
intersect the patch, weighted by the proportion of the patch area
they cover.

There are two exceptions to this default behavior:

* If a percentage of a patches' area greater than the
  coverage-maximum-threshold is covered by a single VectorFeature,
  then the property value from that VectorFeature is copied directly.
  If more than one VectorFeature covers a percentage of area greater
  than the threshold, only the first will be used.

* If the total percentage of a patches' area covered by
  VectorFeatures is less than the coverage-minimum-threshold, the
  target patch variable is set to Not A Number.

By default, the minimum threshold is 10% and the maximum threshold
is 33%. These values may be modified using the four primitives that
follow.
"""
  },
  {
    name: coverage-minimum-threshold,
    type: reporter,
    returns: number,
    tags: ["vector"],
    description: """Reports the current coverage minimum threshold used by [gis:apply-coverage](#gisapply-coverage)."""
  },
  {
    name: set-coverage-minimum-threshold,
    type: command,
    tags: ["vector"],
    arguments: [ { name: new-threshold, type: number } ]
    description: """Sets the current coverage minimum threshold to be used by [gis:apply-coverage](#gisapply-coverage)."""
  },
  {
    name: coverage-maximum-threshold,
    type: reporter,
    returns: number,
    tags: ["vector"],
    description: """Reports the current coverage maximum threshold used by [gis:apply-coverage](#gisapply-coverage)."""
  },
  {
    name: set-coverage-maximum-threshold,
    type: command,
    tags: ["vector"],
    arguments: [ { name: new-threshold, type: number } ]
    description: """Sets the current coverage maximum threshold to be used by [gis:apply-coverage](#gisapply-coverage)."""
  },
  {
    name: "intersects?",
    type: reporter,
    returns: boolean,
    tags: ["vector"],
    arguments: [ { name: x, type: anything }, { name: y, type: anything } ],
    description: """
Reports true if the given objects' spatial representations
share at least one point in common, and false otherwise. The
objects x and y may be any one of:

* a VectorDataset, in which case the object's spatial
    representation is the union of all the points, lines, or polygons
    the dataset contains.
* a VectorFeature, in which case the object's spatial
    representation is defined by the point, line, or polygon the
    feature contains.
* A turtle, in which case the spatial representation is a point.
* A link, whose spatial representation is a line segment
  connecting the two points represented by the turtles the link is
  connecting.
* A patch, whose spatial representation is a rectangular polygon.
* An agentset, whose spatial representation is the union of the
  representations of all of the agents it contains.
* A list containing of any of the items listed here, including
  another list. The spatial representation of such a list is the
  union of the spatial representations of its contents.
"""
  },
  {
    name: "contains?",
    type: reporter,
    returns: boolean,
    tags: ["vector"],
    arguments: [ { name: x, type: anything }, { name: y, type: anything } ],
    description: """
Reports true if every point of *y*'s spatial
representation is also a part of *x*'s spatial
representation. Note that this means that polygons do contain their
boundaries. The objects x and y may be any one of

* a VectorDataset, in which case the object's spatial
  representation is the union of all the points, lines, or polygons
  the dataset contains.
* a VectorFeature, in which case the object's spatial
  representation is defined by the point, line, or polygon the
  feature contains.
* A turtle, in which case the spatial representation is a point.
* A link, whose spatial representation is a line segment
  connecting the two points represented by the turtles the link is
  connecting.
* A patch, whose spatial representation is a rectangular polygon.
* An agentset, whose spatial representation is the union of the
  representations of all of the agents it contains.
* A list containing of any of the items listed here, including
  another list. The spatial representation of such a list is the
  union of the spatial representations of its contents.
"""
  },
  {
    name: "contained-by?",
    type: reporter,
    returns: boolean,
    tags: ["vector"],
    arguments: [ { name: x, type: anything }, { name: y, type: anything } ],
    description: """
Reports true if every point of *x*'s spatial
representation is also a part of *y*'s spatial
representation. The objects x and y may be any one of:

* a VectorDataset, in which case the object's spatial
  representation is the union of all the points, lines, or polygons
  the dataset contains.
* a VectorFeature, in which case the object's spatial
  representation is defined by the point, line, or polygon the
  feature contains.
* A turtle, in which case the spatial representation is a point.
* A link, whose spatial representation is a line segment
  connecting the two points represented by the turtles the link is
  connecting.
* A patch, whose spatial representation is a rectangular polygon.
* An agentset, whose spatial representation is the union of the
  representations of all of the agents it contains.
* A list containing of any of the items listed here, including
  another list. The spatial representation of such a list is the
  union of the spatial representations of its contents.
"""
  },
  {
    name: "have-relationship?",
    type: reporter,
    returns: boolean,
    tags: ["vector"],
    arguments: [ { name: x, type: anything }, { name: y, type: anything } ],
    description: """
Reports true if the spatial representations of the two objects have
the given spatial relationship, and false otherwise. The spatial
relationship is specified using a **Dimensionally Extended Nine-
Intersection Model (DE-9IM)** matrix. The matrix consists of 9
elements, each of which specifies the required relationship between
the two objects' interior space, boundary space, or exterior
space. The elements must have one of six possible values:

* "T", meaning the spaces must intersect in some way
* "F", meaning the spaces must not intersect in any way
* "0", meaning the dimension of the spaces'
  intersection must be zero (i.e., it must be a point or non-empty
  set of points).
* "1", meaning the dimension of the spaces'
  intersection must be one (i.e., it must be a line or non-empty set
  of line segments).
* "2", meaning the dimension of the spaces'
  intersection must be two (i.e., it must be a polygon or set of
  polygons whose area is greater than zero).
* "*", meaning that the two spaces may have any
  relationship.

For example, this matrix:
      <table width="50%" border="1" style="text-align: center; margin: 0 auto;">
<tr>
  <td rowspan="2" colspan="2">
  <td colspan="3">
    x
  <tr>
  <td> Interior <td> Boundary <td> Exterior <tr>
  <td rowspan="3">
    y
  <td> Interior <td> T <td> * <td> * <tr>
  <td> Boundary <td> * <td> * <td> * <tr>
  <td> Exterior <td> F <td> F <td> * </table>

would return true if and only if some part of object *x*'s
interior lies inside object *y*'s interior, and no part of
object *x*'s interior or boundary intersects object
*y*'s exterior. This is essentially a more restrictive
form of the `contains?` primitive; one in which polygons are
not considered to contain their boundaries.

The matrix is given to the `have-relationship?` primitive as
a string, whose elements are given in the following order:
      <table width="25%" border="1" style="text-align: center; margin: 0 auto;" align="center">
<tr>
  <td> 1 <td> 2 <td> 3 <tr>
  <td> 4 <td> 5 <td> 6 <tr>
  <td> 7 <td> 8 <td> 9 </table>

So to use the example matrix above, you would write:

```
gis:have-relationship? x y "T*****FF*"
```

A much more detailed and formal description of the DE-9IM matrix
and the associated point-set theory can be found in the <a href="http://www.opengeospatial.org/standards/sfs" target="_blank">OpenGIS Simple
Features Specification for SQL</a>.

The objects x and y may be any one of:

* a VectorDataset, in which case the object's spatial
  representation is the union of all the points, lines, or polygons
  the dataset contains.
* a VectorFeature, in which case the object's spatial
  representation is defined by the point, line, or polygon the
  feature contains.
* A turtle, in which case the spatial representation is a point.
* A link, whose spatial representation is a line segment
  connecting the two points represented by the turtles the link is
  connecting.
* A patch, whose spatial representation is a rectangular polygon.
* An agentset, whose spatial representation is the union of the
  representations of all of the agents it contains.
* A list containing of any of the items listed here, including
  another list. The spatial representation of such a list is the
  union of the spatial representations of its contents.
"""
  },
  {
    name: "relationship-of"
    type: reporter,
    returns: string,
    tags: ["vector"],
    arguments: [ { name: x, type: anything }, { name: y, type: anything } ],
    description: """
Reports the **Dimensionally Extended Nine-Intersection Model
(DE-9IM)** matrix that describes the spatial relationship of the
two objects. The matrix consists of 9 elements, each of which
describes the relationship between the two objects' interior
space, boundary space, or exterior space. Each element will
describe the dimension of the intersection of two spaces, meaning
that it may have one of four possible values:

* "-1", meaning the spaces do not intersect
* "0", meaning the dimension of the spaces'
  intersection is zero (i.e., they intersect at a point or set of
  points).
* "1", meaning the dimension of the spaces'
  intersection is one (i.e., they intersect along one or more lines).
* "2", meaning the dimension of the spaces'
  intersection is two (i.e., their intersection is a non-empty
  polygon).


For example, the two polygons x and y shown here:
<center>
  <img alt="" src="images/intersecting-polygons.png">
</center>

have the following DE-9IM matrix:
<table width="50%" border="1" style="text-align: center; margin: 0 auto;" align="center">
  <tr>
  <td rowspan="2" colspan="2">
  <td colspan="3">
    x
  <tr>
  <td> Interior <td> Boundary <td> Exterior <tr>
  <td rowspan="3">
    y
  <td> Interior <td> 2 <td> 1 <td> 2 <tr>
  <td> Boundary <td> 1 <td> 0 <td> 1 <tr>
  <td> Exterior <td> 2 <td> 1 <td> 2 </table>

Which would be reported by the `relationship-of` primitive
as the string "212101212".

A much more detailed and formal description of the DE-9IM matrix
and the associated point-set theory can be found in the <a href="http://www.opengeospatial.org/standards/sfs" target="_blank">OpenGIS Simple
Features Specification for SQL</a>.

The objects x and y may be any one of:

* a VectorDataset, in which case the object's spatial
  representation is the union of all the points, lines, or polygons
  the dataset contains.
* a VectorFeature, in which case the object's spatial
  representation is defined by the point, line, or polygon the
  feature contains.
* A turtle, in which case the spatial representation is a point.
* A link, whose spatial representation is a line segment
  connecting the two points represented by the turtles the link is
  connecting.
* A patch, whose spatial representation is a rectangular polygon.
* An agentset, whose spatial representation is the union of the
  representations of all of the agents it contains.
* A list containing of any of the items listed here, including
  another list. The spatial representation of such a list is the
  union of the spatial representations of its contents.
"""
  },
    {
    name: intersecting,
    type: reporter,
    returns: agentset,
    infix: true,
    tags: ["vector"],
    arguments: [ { name: patch-set, type: patchset }, { name: data, type: anything } ],
    description: """
Reports a new agent set containing only those members of the given
agent set which intersect given GIS *data*, which may be any
one of: a VectorDataset, a VectorFeature, an Agent, an Agent Set,
or a list containing any of the above.
"""
  },
  {
    name: width-of,
    type: reporter,
    returns: number,
    tags: ["raster"],
    arguments: [ { name: RasterDataset, type: dataset } ],
    description: """
Reports the number of columns in the dataset. Note that this is the
number of cells from left to right, not the width of the dataset in
GIS space.
"""
  },
  {
    name: height-of,
    tags: ["raster"],
    type: reporter,
    returns: number,
    arguments: [ { name: RasterDataset, type: dataset } ]
    description: """
Reports the number of rows in the dataset. Note that this is the
number of cells from top to bottom, not the height of the dataset
in GIS space.
"""
  },
  {
    name: raster-value,
    type: reporter,
    returns: number,
    tags: ["raster"],
    arguments: [ { name: RasterDataset, type: dataset }, { name: x, type: number }, { name: y, type: number } ]
    description: """
Reports the value of the given raster dataset in the given cell.
Cell coordinates are numbered from left to right, and from top to
bottom, beginning with zero. So the upper left cell is (0, 0), and
the bottom right cell is (`gis:width-of dataset` - 1,
`gis:height-of dataset` - 1).
"""
  },
  {
    name: set-raster-value,
    type: command,
    tags: ["raster"],
    arguments: [
      { name: RasterDataset, type: dataset },
      { name: x, type: number },
      { name: y, type: number },
      { name: value, type: number }
    ],
    description: """
Sets the value of the given raster dataset at the given cell to a
new value. Cell coordinates are numbered from left to right, and
from top to bottom, beginning with zero. So the upper left cell is
(0, 0), and the bottom right cell is (`gis:width-of dataset`
- 1, `gis:height-of dataset` - 1).
"""
  },
  {
    name: minimum-of,
    type: reporter,
    returns: number,
    tags: ["raster"],
    arguments: [ { name: RasterDataset, type: dataset } ],
    description: "Reports the highest value in the given raster dataset."
  },
  {
    name: maximum-of,
    type: reporter,
    returns: number,
    tags: ["raster"],
    arguments: [ { name: RasterDataset, type: dataset } ],
    description: "Reports the lowest value in the given raster dataset."
  },
  {
    name: sampling-method-of,
    type: reporter,
    returns: string,
    tags: ["raster"],
    arguments: [ { name: RasterDataset, type: dataset } ],
    description: """
Reports the sampling method used to compute the value of the given
raster dataset at a single point, or over an area smaller than a
single raster cell. Sampling is performed by the GIS extension
primitives [raster-sample](#gisraster-sample), [resample](#gisresample), [convolve](#gisconvolve),
and [apply-raster](#gisapply-raster). The sampling
method will be one of the following:

* `"NEAREST_NEIGHBOR"`: the value of the cell
  nearest the sampling location is used.
* `"BILINEAR"`: the value of the four nearest
  cells are sampled by linear weighting, according to their
  proximity to the sampling site.
* `"BICUBIC"`: the value of the sixteen nearest
  cells are sampled, and their values are combined by weight
  according to a piecewise cubic polynomial recommended by Rifman
  (see *Digital Image Warping*, George Wolberg, 1990, pp
  129-131, IEEE Computer Society Press).
* `"BICUBIC_2"`: the value is sampled using the
  same procedure and the same polynomial as with `BICUBIC`
  above, but using a different coefficient. This method may produce
  somewhat sharper results than `BICUBIC`, but that result
  is data dependent.

For more information on these sampling methods and on raster
sampling in general, see <a href="https://en.wikipedia.org/wiki/Image_scaling" target="_blank">this wikipedia
article</a>.
"""
  },
  {
    name: set-sampling-method,
    type: command,
    tags: ["raster"],
    arguments: [ { name: RasterDataset, type: dataset }, { name: sampling-method, type: string } ],
    description: """
Sets the sampling method used by the given raster dataset at a
single point, or over an area smaller than a single raster cell.
Sampling is performed by the GIS extension primitives [raster-sample](#gisraster-sample), [resample](#gisresample), [convolve](#gisconvolve),
and [apply-raster](#gisapply-raster). The sampling
method must be one of the following:

*  `"NEAREST_NEIGHBOR"`
*  `"BILINEAR"`
*  `"BICUBIC"`
*  `"BICUBIC_2"`

See [sampling-method-of](#gissampling-method-of) above
for a more specific description of each sampling method.
"""
  },
  {
    name: raster-sample,
    type: reporter,
    returns: number,
    tags: ["raster"]
    arguments: [ { name: RasterDataset, type: dataset }, { name: sample-location, type: anything } ]
    description: """
Reports the value of the given raster over the given location. The
location may be any of the following:

* A list of length 2, which is taken to represent a point in
  netlogo space (`[xcor ycor]`) of the sort reported by
  [location-of](#gislocation-of) Vertex. The raster
  dataset is sampled at the point of that location.
* A list of length 4, which is taken to represent an envelope in
  GIS space, of the sort reported by [envelope-of](#gisenvelope-of). The raster dataset is sampled
  over the area of that envelope.
* A patch, in which case the raster dataset is sampled over the
  area of the patch.
* A turtle, in which case the raster dataset is sampled at the
  location of that turtle.
* A Vertex, in which case the raster dataset is sampled at the
  location of that Vertex.

If the requested location is outside the area covered by the raster
dataset, this primitive reports the special value representing
"not a number", which is printed by NetLogo as
"NaN". Using the special "not a number" value
as an argument to primitives that expect a number may cause an
error, but you can test the value reported by this primitive to
filter out "not a number" values. A value that is not a
number will be neither less than nor greater than a number value,
so you can detect "not a number" values using the
following:

```
let value gis:raster-sample dataset turtle 0
; set color to blue if value is a number, red if value is "not a number"
ifelse (value <= 0) or (value >= 0)
[ set color blue ]
[ set color red ]
```

If the requested location is a point, the sample is always computed
using the method set by [set-sampling-method](#gisset-sampling-method). If the
requested location is an area (i.e., an envelope or patch), the
sample is computed by taking the average of all raster cells
covered by the requested area.
"""
  },
  {
    name: raster-world-envelope,
    type: reporter,
    returns: list,
    tags: ["raster"],
    arguments: [
      { name: RasterDataset, type: dataset },
      { name: x, type: number },
      { name: y, type: number }
    ],
    description: """
Reports the GIS envelope needed to match the boundaries of NetLogo
patches with the boundaries of cells in the given raster dataset.
This envelope could then be used as an argument to [set-transformation-ds](#gisset-transformation-ds).

There may be more cells in the dataset than there are patches in
the NetLogo world. In that case, you will need to select a subset
of cells in the dataset by specifying which cell in the dataset you
want to match with the upper-left corner of the NetLogo world.
Cells are numbered from left to right, and from top to bottom,
beginning with zero. So the upper left cell is (0, 0), and the
bottom right cell is (`gis:width-of dataset` - 1, `gis:height-of dataset` - 1).
"""
  },
  {
    name: create-raster,
    tags: ["raster"],
    type: reporter,
    returns: dataset,
    arguments: [ { name: width, type: number }, { name: height, type: number }, { name: envelope, type: list } ]
    description: """
Creates and reports a new, empty raster dataset with the given
number of columns and rows, covering the given envelope.
"""
  },
  {
    name: resample,
    type: reporter,
    returns: dataset,
    tags: ["raster"]
    arguments: [
      { name: RasterDataset, type: dataset },
      { name: envelope, type: list },
      { name: width, type: number },
      { name: height, type: number }
    ],
    description: """
Reports a new dataset that consists of the given RasterDataset
resampled to cover the given envelope and to contain the given
number of columns and rows. If the new raster's cells are
smaller than the existing raster's cells, they will be
resampled using the method set by [set-sampling-method](#gisset-sampling-method). If the new
cells are larger than the original cells, they will be sampled
using the `"NEAREST_NEIGHBOR"` method.
"""
  },
    {
    name: convolve,
    type: reporter,
    returns: dataset,
    tags: ["raster"],
    arguments: [
      { name: RasterDataset,  type: dataset },
      { name: kernel-rows,    type: number },
      { name: kernel-columns, type: number },
      { name: kernel,         type: list },
      { name: key-column,     type: number },
      { name: key-row,        type: number }
    ],
    description: """
Reports a new raster whose data consists of the given raster
convolved with the given kernel.

A convolution is a mathematical operation that computes each output
cell by multiplying elements of a kernel with the cell values
surrounding a particular source cell. A kernel is a matrix of
values, with one particular value defined as the "key
element", the value that is centered over the source cell
corresponding to the destination cell whose value is being
computed.

The values of the kernel matrix are given as a list, which
enumerates the elements of the matrix from left to right, top to
bottom. So the elements of a 3-by-3 matrix would be listed in the
following order:
      <table width="25%" border="1" style="text-align: center; margin: 0 auto;" align="center">
<tr>
  <td> 1 <td> 2 <td> 3 <tr>
  <td> 4 <td> 5 <td> 6 <tr>
  <td> 7 <td> 8 <td> 9 </table>

The key element is specified by column and row within the matrix.
Columns are numbered from left to right, beginning with zero. Rows
are numbered from top to bottom, also beginning with zero. So, for
example, the kernel for the horizontal <a href="https://en.wikipedia.org/wiki/Sobel_operator" target="_blank">Sobel operator</a>,
which looks like this:
      <table width="25%" border="1" style="text-align: center; margin: 0 auto;" align="center">
<tr>
  <td> 1 <td> 0 <td> -1 <tr>
  <td> 2 <td> 0 <br> <small>(key)</small> <td> -2 <tr>
  <td> 1 <td> 0 <td> -1 </table>

would be specified as follows:

```
let horizontal-gradient gis:convolve dataset 3 3 [1 0 -1 2 0 -2 1 0 -1] 1 1
```
"""
  },
  {
    name: apply-raster,
    type: command,
    tags: ["raster"],
    arguments: [
      { name: RasterDataset, type: dataset },
      { name: patch-variable, type: reference }
    ],
    description: """

Copies values from the given raster dataset to the given patch
variable, resampling the raster as necessary so that its cell
boundaries match up with NetLogo patch boundaries. This resampling
is done as if using [resample](#gisresample) rather
than [raster-sample](#gisraster-sample), for the sake
of efficiency. However, patches not covered by the raster are
assigned values of "not a number" in the same way that
[raster-sample](#gisraster-sample) reports values for
locations outside the raster.
"""
  },
  {
    name: drawing-color,
    tags: ["drawing"],
    type: reporter,
    returns: "list or number",
    description: """
Reports the color used by the GIS extension to draw vector features
into the NetLogo drawing layer. Color can be represented either as
a NetLogo color (a single number between zero and 140) or an RGB
color (a list of 3 numbers). See details in the [Colors]({{netlogoUrl}}programming.html#colors) section of the
Programming Guide.
"""
  },
  {
    name: set-drawing-color,
    type: command,
    tags: ["drawing"],
    arguments: [ { name: color, type: "list or number" } ]
    description: """
Sets the color used by the GIS extension to draw vector features
into the NetLogo drawing layer. *Color* can be represented
either as a NetLogo color (a single number between zero and 140) or
an RGB color (a list of 3 numbers). See details in the [Colors]({{{netlogoUrl}}}programming.html#colors) section of the Programming Guide.
"""
  },
  {
    name: draw,
    type: command,
    tags: ["drawing"],
    arguments: [ { name: vector-data, type: anything }, { name: line-thickness, type: number } ],
    description: """
Draws the given vector data to the NetLogo drawing layer, using the
current GIS drawing color, with the given line thickness. The data
may consist either of an entire VectorDataset, or a single
VectorFeature. This primitive draws only the boundary of polygon
data, and for point data, it fills a circle with a radius equal to
the line thickness.
"""
  },
    {
    name: fill,
    type: command,
    tags: ["drawing"],
    arguments: [ { name: vector-data, type: anything }, { name: line-thickness, type: number } ],
    description: """
Fills the given vector data in the NetLogo drawing layer using the
current GIS drawing color, using the given line thickness around
the edges. The data may consist either of an entire VectorDataset,
or a single VectorFeature. For point data, it fills a circle with a
radius equal to the line thickness.
"""
  },
    {
    name: paint,
    type: command,
    tags: ["drawing"],
    arguments: [ { name: RasterDataset, type: dataset }, { name: transparency, type: number } ],
    description: """
Paints the given raster data to the NetLogo drawing layer. The
highest value in the dataset is painted white, the lowest is
painted in black, and the other values are painted in shades of
gray scaled linearly between white and black.

The *transparency* input determines how transparent the new
image in the drawing will be. Valid inputs range from 0 (completely
opaque) to 255 (completely transparent).
"""
  },
  {
    name: import-wms-drawing,
    type: command,
    tags: ["drawing"],
    arguments: [
      { name: server-url, type: string },
      { name: spatial-reference, type: string },
      { name: layers, type: string },
      { name: transparency, type: string }
    ],
    description: """
Imports an image into the NetLogo drawing layer using the
<a href="http://www.opengeospatial.org/standards/wms" target="_blank">Web Mapping Service</a>
 protocol, as defined by the <a href="http://www.opengeospatial.org/" target="_blank">
Open Geospatial Consortium</a>.

The *spatial reference* and *layers* inputs should be
given as strings. The *spatial reference* input corresponds to
the **SRS** parameter to the **GetMap** request as defined in
section 7.2.3.5 of version 1.1.1 of the WMS standard. The
*layers* input corresponds to the **LAYERS** parameter to
the as defined in 7.2.3.3 of version 1.1.1 of the WMS standard.

You can find the list of valid spatial reference codes and layer
names by examining the response to a **GetCapabilities** request
to the WMS server. Consult the relevant standard for instructions
on how to issue a **GetCapabilities** request to the server and
how to interpret the results.

The *transparency* input determines how transparent the new
image in the drawing will be. Valid inputs range from 0 (completely
opaque) to 255 (completely transparent).
"""
  }
]
